<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.6">
  <compounddef id="md_markdown_creating_autonomy_application" kind="page">
    <compoundname>md_markdown_creating_autonomy_application</compoundname>
    <title>Creating an Autonomy Application</title>
    <detaileddescription>
<para>To create a new autonomy application, we need to create a new state machine which defines the logic flow and a robot system which coordinates the hardware on the physical (or virtual) robot. We need to implement the following components:</para><para><table rows="6" cols="2"><row>
<entry thead="yes"><para>Component </para></entry><entry thead="yes"><para>Description  </para></entry></row>
<row>
<entry thead="no"><para>Robot System </para></entry><entry thead="no"><para>Provides sensor data and accepts control commands </para></entry></row>
<row>
<entry thead="no"><para>Robot System Handler </para></entry><entry thead="no"><para>Instantiates robot system and manages its control threads </para></entry></row>
<row>
<entry thead="no"><para>Actions </para></entry><entry thead="no"><para>Commands to execute when switching between states </para></entry></row>
<row>
<entry thead="no"><para>Guards </para></entry><entry thead="no"><para>Check if the transition between states is valid or not </para></entry></row>
<row>
<entry thead="no"><para>Internal Actions </para></entry><entry thead="no"><para>Process robot state continuously and trigger actions accordingly </para></entry></row>
</table>
</para><para><heading level="2">Creating a Robot System</heading>
</para><para>A robot system is responsible for owning any <ref refid="md_markdown_class_groups" kindref="compound">ControllerHardwareConnectors</ref> and interacting with any hardware that the autonomy application will be utilizing. Examples can be found in <ulink url="https://github.com/jhu-asco/aerial_autonomy/tree/master/include/aerial_autonomy/robot_systems">include/robot_systems</ulink>. New robot systems should extend <ref refid="classBaseRobotSystem" kindref="compound">BaseRobotSystem</ref> and add any ControllerHardwareConnectors to the system in the derived class constructor using <computeroutput>controller_hardware_connector_container_.setObject(my_controller_connector_)</computeroutput>. Keep in mind that only one instance of each <ref refid="classControllerHardwareConnector" kindref="compound">ControllerHardwareConnector</ref> type can be stored in the container. The new robot system should expose any additional hardware functionality that will be used in the state machine, e.g. <computeroutput>takeoff()</computeroutput> or <computeroutput>land()</computeroutput> for the <computeroutput><ref refid="classUAVSystem" kindref="compound">UAVSystem</ref></computeroutput>.</para><para>The state machine actions will have access to the robot system and interact with controllers by calling the robot system <computeroutput>setGoal</computeroutput> function templated on the controller it wants to use to navigate to the given goal.</para><para><heading level="2">Creating Actions</heading>
</para><para>Actions define commands to execute when transitioning between states. Examples can be found in <computeroutput>include/actions_guards</computeroutput>. Actions which do not need access to the event which triggered the action should derive from <computeroutput><ref refid="structEventAgnosticActionFunctor" kindref="compound">EventAgnosticActionFunctor</ref>&lt;RobotSystemT, LogicStateMachineT&gt;</computeroutput> and override the <computeroutput>run(RobotSystemT&amp; LogicStateMachineT&amp;)</computeroutput> function with the command to be executed. See <computeroutput>include/land_functors.h</computeroutput> for an example.</para><para>Actions which do need access to the triggering event should derive from <computeroutput><ref refid="structActionFunctor" kindref="compound">ActionFunctor</ref>&lt;EventT, RobotSystemT, LogicStateMachineT&gt;</computeroutput> and override the run function with the command to execute. See <computeroutput>include/position_control_functors.h</computeroutput> for an example.</para><para><heading level="2">Creating Internal Actions</heading>
</para><para>Internal actions define a behavior that is executed while in a particular state. They should derive from <computeroutput><ref refid="structEventAgnosticActionFunctor" kindref="compound">EventAgnosticActionFunctor</ref>&lt;RobotSystemT, LogicStateMachineT&gt;</computeroutput> and override its <computeroutput>run</computeroutput> function with the intended behavior. See <computeroutput><ref refid="structPositionControlInternalActionFunctor__" kindref="compound">PositionControlInternalActionFunctor_</ref></computeroutput> in <computeroutput>include/position_control_functors.h</computeroutput> for an example.</para><para><heading level="2">Creating Guards</heading>
</para><para>Guards check if a triggered transition between states is valid or not. For example, the <computeroutput><ref refid="structTakeoffTransitionGuardFunctor__" kindref="compound">TakeoffTransitionGuardFunctor_</ref></computeroutput> keeps a <computeroutput><ref refid="classUAVSystem" kindref="compound">UAVSystem</ref></computeroutput> from taking off if the battery level percentage is below some threshold. Guards which do not need access to the triggering event should derive from <computeroutput><ref refid="structEventAgnosticGuardFunctor" kindref="compound">EventAgnosticGuardFunctor</ref>&lt;RobotSystemT, LogicStateMachineT&gt;</computeroutput> and override the <computeroutput>guard</computeroutput> function to return true when a transition is valid and false otherwise.</para><para>Guards which do need access to the triggering event should inherit from <computeroutput><ref refid="structGuardFunctor" kindref="compound">GuardFunctor</ref>&lt;EventT, RobotSystemT, LogicStateMachineT&gt;</computeroutput> and override its <computeroutput>guard</computeroutput> fuction. See <computeroutput><ref refid="structPositionControlTransitionGuardFunctor__" kindref="compound">PositionControlTransitionGuardFunctor_</ref></computeroutput> in <computeroutput>include/position_control_functors.h</computeroutput> for an example.</para><para><heading level="2">Creating a State Machine</heading>
</para><para>The state machine defines the logic of the system using the defined actions, states, and guards. A &quot;front end&quot; for the state machine defines the connections and transitions between states. The front end should derive from both <computeroutput>msmf::state_machine_def&lt;StateMachineFrontEnd&gt;</computeroutput> and <computeroutput><ref refid="classBaseStateMachine" kindref="compound">BaseStateMachine</ref>&lt;RobotSystemT&gt;</computeroutput>. Its <computeroutput>transition_table</computeroutput> will define the state machine itself by specifying which action will cause which state transitions and which guards will check the validity of the transitions. See <computeroutput>include/state_machines/uav_state_machine.h</computeroutput> and its associated flow chart below for an example and see <ulink url="http://www.boost.org/doc/libs/1_63_0/libs/msm/doc/HTML/ch03s02.html">here</ulink> for a more in depth explanation of the underlying boost mechanisms.</para><para><image type="html" name="state_machine.png"></image>
</para><para>The state machine that we will interact with will be of type <computeroutput><ref refid="classboost_1_1msm_1_1back_1_1thread__safe__state__machine" kindref="compound">boost::msm::back::thread_safe_state_machine</ref>&lt;StateMachineFrontEnd&gt;</computeroutput>.</para><para>Any new state machine must include <computeroutput>using <ref refid="classBaseStateMachine" kindref="compound">BaseStateMachine</ref>&lt;<ref refid="classUAVSystem" kindref="compound">UAVSystem</ref>&gt;::no_transition</computeroutput> to avoid type ambiguities.</para><para><heading level="2">Creating a System Handler</heading>
</para><para>The system handler should have a member of type <computeroutput><ref refid="classCommonSystemHandler" kindref="compound">CommonSystemHandler</ref>&lt;LogicStateMachineT, EventManagerT, RobotSystemT&gt;</computeroutput>, which will automatically take care of instantiating and managing the logic state machine it is templated on. The system handler must call the <ref refid="classCommonSystemHandler" kindref="compound">CommonSystemHandler</ref> <computeroutput>startTimers</computeroutput> function to start the state machine. The system handler will need to instantiate the robot system and any hardware drivers and spawn any timers for stepping controllers owned by the robot system. See <computeroutput>include/system_handlers/uav_system_handler.h</computeroutput> for an example.</para><para><heading level="2">Creating a Node</heading>
</para><para>Create an executable with the following structure: <verbatim>int main(int argc, char** argv) {
  ros::init(argc, argv);
  ros::NodeHandle nh;
  // Load config into config
  MySystemHandler&lt;MyStateMachine, MyEventManager&gt;(nh, config)
  ros::spin();
} 
</verbatim></para><para>See <computeroutput><ref refid="uav__system__node_8cpp" kindref="compound">src/system_handler_nodes/uav_system_node.cpp</ref></computeroutput> for an example. </para>    </detaileddescription>
  </compounddef>
</doxygen>
